=== smclint testcases
Smclint testcases require I, Zicsr, and m-mode interrupts (Smclint).
Since no clint tests are currently available in riscv-arch-test, these tests are created to verify CLINT and that after adding CLIC extension to SAIL that CLINT mode is not broken.
Full coverage of possible interrupts would be difficult because different implementations can choose which are implemented and mip/mie bits can be hardwired to 0.
So the smclint tests only compare up to two interrupts at a time and default to using msip and mtip interrupts.

Below is generic test pseudo code that is used by the smclint tests to stimulate different behavior.  
anything in ALL_CAPS are defines that can be overwritten with -D or at top of test or in model_test.h
[%autofit]
----
/* to stimulate different test behavior using the same generic test pseudo code, 
   individual tests will #define different default values here */ 

#include "model_test.h"
#include "arch_test.h"

current mtvec/mscratch saved (used by arch_test.h so needs to be restored at end of test)
program mie csr RVMODEL_SET_MIE
RVMODEL_SET_INT1
fence
set mstatus.mie to RVMODEL_MSTATUS_MIE
RVMODEL_WFI
jump to finish /* e.g. if RVMODEL_SET_INT1 is defined to actually not set interrupt1, or interrupt level is 0, all signatures would stay default */

m_interrupt_handler1:
  save signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  modify mtvec to point to interrupt handler2:
  RVMODEL_CLEAR_INT1
  RVMODEL_SET_INT2
  set mstatus.mie to RVMODEL_MSTATUS_MIE /* e.g. if RVMODEL_CLEAR_INT1 was defined to actually not clear interrupt1, interrupt1 is still asserted, clint would preempt and jump to interrupt handler2 */
  modify mepc to jump to finsh
  save signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  mret

m_interrupt_handler2:
  save signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  RVMODEL_CLEAR_INT2
  clear mstatus.mpie (so mstatus.mie is 0 after mret)
  mret

finish:
restore mtvec, mscratch for arch_test.h
----

Defaults:
[%autofit]
----
RVMODEL_WFI = wfi
RVMODEL_CLEAR_ALL_INTS = RVMODEL_CLEAR_MSW_INT; RVMODEL_CLEAR_MTIMER_INT
RVMODEL_MSTATUS_MIE = MSTATUS_MIE // 0x8
RVMODEL_SET_MIE = (MIE_MSIE | MIE_MTIE) // 0x8 | 0x80
RVMODEL_CLEAR_MSTATUS_MPIE = MSTATUS_MPIE // 0x80
RVMODEL_MTVEC_MODE = 0
RVMODEL_MSTATUS_MASK = (MSTATUS_MIE | MSTATUS_MPIE | MSTATUS_MPP) // mask signature of mstatus to only compare mie, mpie, mpp bits.
RVMODEL_MIP_MASK = RVMODEL_SET_MIE
RVMODEL_ECALL = <empty>
----

==== msw-01.S
.Description: tests if RVMODEL_SET_MSW_INT is working, hangs in infinite loop otherwise
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = <EMPTY>
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = <EMPTY>
 RVMODEL_WFI = jump_to_self 
----
Coverage
----
msip trigger | verify RVMODEL_SET_MSW_INT trigger
msip clear   | verify RVMODEL_CLEAR_MSW_INT clear
mip.msip     | verify mip signature 0/1
mcause       | verify machine software interrupt signature
mstatus      | verify mstatus.mie/mpie/mpp signature in interrupt handler and after mret
mtvec        | verify interrupt uses mtvec to calculate pc of interrupt handler (direct)
mepc         | verify mepc location is jump_to_self location
----
==== mtimer-01.S
.Description: tests if RVMODEL_SET_MTIMER_INT is working, hangs in infinite loop otherwise
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MTIMER_INT
 RVMODEL_SET_INT2 = <EMPTY>
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_CLEAR_INT2 = <EMPTY>
 RVMODEL_WFI = jump_to_self  
----
Coverage
----
mtip trigger | verify RVMODEL_SET_MTIMER_INT trigger
mtip clear   | verify RVMODEL_CLEAR_MTIMER_INT clear
mip.mtip     | verify mip signature 0/1
mcause       | verify machine timer interrupt signature
mstatus      | verify mstatus.mie/mpie/mpp signature in interrupt handler and after mret
mtvec        | verify interrupt uses mtvec to calculate pc of interrupt handler (direct)
mepc         | verify mepc location is jump_to_self location
----
==== nomint-01.S
.Description: expect interrupts will not trigger in m-mode unless mstatus.mie is set
- enable mie
- generate interrupts
- nop
- jump to finish
[%autofit]
----
 RVMODEL_MSTATUS_MIE = 0
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
mstatus.mie | verify no interrupt occurs in m-mode if mstatus.mie is 0
----
==== nomint-02.S
.Description: expect interrupts will not trigger in m-mode unless mie.x is set
- generate interrupts
- enable mstatus.mie
- nop
- jump to finish
[%autofit]
----
 RVMODEL_SET_MIE = 0 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
mie.msip | verify no msw interrupt occurs if mie.msip is 0
mie.mtip | verify no mtimer interrupt occurs if mie.mtip is 0
----
==== wfi-01.S
.Description: expect wfi to behave like a nop when a single interrupt is pending when mstatus.mie is disabled
- enable mie CSR
- generate interrupts
- wfi
- wakeup
- jump to finish
[%autofit]
----
 RVMODEL_MSTATUS_MIE = 0
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT
----
Coverage
----
mstatus.mie | verify no interrupt occurs in m-mode if mstatus.mie is 0
wfi | verify wakeup/nop occurs with mstatus.mie = 0
wfi | verify wakeup/nop occurs with pending interrupt
----
==== direct-01.S 
.Description: trigger, clear, retrigger same interrupt.
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd m-mode handler
- clear 2nd interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
----
Coverage - same as msw-01.S plus
----
mtvec.mode     | verify direct mode is used to handle interrupt
msip retrigger | verify after mstatus.mie is enabled in interrupt handler, msip will retrigger
----
==== direct-02.S 
.Description: trigger, clear, retrigger single interrupt, no 2nd clear. 
Stimulates pending interrupt after setting mstatus.mpie followed by mret
mstatus.mie should be cleared after mret so pending interrupt is not taken
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = <EMPTY> 
----
Coverage - same as msw-01.S plus
----
msip retrigger | verify after mstatus.mie is enabled after mret, msip will retrigger
----
==== vectored-01.S 
.Description: trigger, clear, retrigger single interrupt, vectored-mode.
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger vectored m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd vectored m-mode handler
- clear 2nd interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT
----
Coverage - same as msw-01.S plus
----
mtvec.mode     | verify vectored mode is used to handle interrupt
msip retrigger | verify after mstatus.mie is enabled in interrupt handler, msip will retrigger
----
==== vectored-02.S 
.Description: trigger, clear, retrigger single interrupt, no 2nd clear. 
Stimulates pending interrupt after setting mstatus.mpie followed by mret, vectored-mode.
mstatus.mie should be cleared after mret so pending interrupt is not taken
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger vectored m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd vectored m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = <EMPTY> 
----
Coverage - same as msw-01.S plus
----
mtvec.mode     | verify vectored mode is used to handle interrupt
msip retrigger | verify after mstatus.mie is enabled after mret, msip will retrigger
----
==== ecall-01.S 
.Description: trigger, clear, set interrupt pending, ecall
Stimulates ecall within an interrupt handler to stimulate mcause.interrupt toggling
mstatus.mie should be cleared after mret so pending interrupt is not taken
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode vectored interrupt handler
- ecall instruction to trigger (direct) exception handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
- re-trigger interrupt
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = <EMPTY>
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = <EMPTY>
 RVMODEL_ECALL = ecall
----
Coverage - same as msw-01.S plus
----
mtvec.mode           | verify vectored mode is used to handle interrupt
mcause.interrupt 0/1 | verify ecall toggles mcause.interrupt, uses direct exception handler
----
==== level-01.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, mtvec.mode=direct
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- trigger 2nd m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
----
Coverage
----
Interrupt ordering - both interrupts asserted in msw interrupt handler
----
==== level-02.S
.Description: verify interrupt level order, swap 2 interrupt order, mtvec.mode=direct
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- set mstatus.mie
- trigger 2nd m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MTIMER_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
----
----
Interrupt ordering - both interrupts asserted in mtimer interrupt handler
----
==== level-03.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, mtvec.mode=vectored
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger vectored m-mode handler
- generate interrupt 2 (both interrupts now pending)
- set mstatus.mie
- trigger 2nd vectored m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
----
Coverage
----
mtvec.mode         | verify vectored mode is used to handle interrupt, signature of higher priority interrupt
Interrupt ordering | both interrupts asserted in msw interrupt handler
----
==== level-04.S
.Description: verify interrupt level order, swap 2 interrupt order, mtvec.mode=vectored
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger vectored m-mode handler
- generate interrupt 2 (both interrupts now pending)
- set mstatus.mie
- trigger 2nd vectored m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MTIMER_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
----
Coverage
----
mtvec.mode         | verify vectored mode is used to handle interrupt, signature of higher priority interrupt
Interrupt ordering | both interrupts asserted in mtimer interrupt handler
----

