# This coverpoint validates M-mode interrupt priority mechanism
# Evaluates interrupt handling when both software and timer interrupts are simultaneously pending
# Verifies correct interrupt resolution and machine state preservation
CHK_M_INTR_PRIORITY:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrc: 0
      csrrs: 0
      sw   : 0  
      mret : 0 
  val_comb:     
    # Software interrupt scenario validation (This coverpoint will never hit in case of timer interrupt is taken first due to mip specific value check)    
     '(call_type == "interrupt") and ((mstatus & ${MSTATUS_MPP}) == ${MSTATUS_MPP_M}) and ((mstatus & ${MSTATUS_MPIE}) == ${MSTATUS_MPIE}) and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mcause & ${INTERRUPT_MASK}) == ${CAUSE_M_SOFT_INTR}) and ((mie & ${MIE_MSIE}) == ${MIE_MSIE}) and ((mie & ${MIE_MTIE}) == ${MIE_MTIE}) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP}) and ((mip & ${MIP_MTIP}) == ${MIP_MTIP})': 0  # Validates software interrupt handling when simultaneously pending with timer interrupt, checking machine status register configuration(MPP, MPIE, MIE), interrupt cause, and interrupt enable/pending states for both software and timer interrupt.
    # Timer interrupt scenario validation
     '(call_type == "interrupt") and ((mstatus & ${MSTATUS_MPP}) == ${MSTATUS_MPP_M}) and ((mstatus & ${MSTATUS_MPIE}) == ${MSTATUS_MPIE}) and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mcause & ${INTERRUPT_MASK}) == ${CAUSE_M_TIMER_INTR}) and ((mie & ${MIE_MTIE}) == ${MIE_MTIE}) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})': 0 # Validates timer interrupt handling, verifying machine status register configuration(MPP, MPIE, MIE), interrupt cause, and timer interrupt enable/pending states.     
    
# This coverpoint checks MIP register write protection
# Confirms Machine Interrupt Pending (MIP) register remains read-only
CHK_MIP_PERMISSONS:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrw: 0
  val_comb: 
      # Validate MIP bits across different register segments
      '((mip & ${MIP_MSIP}) != 1)' : 0 # Ensures Machine Software Interrupt Pending (MSIP) bit cannot be modified by write operations, maintaining read-only protection.
      '((mip & ${MIP_MTIP}) != 1)' : 0 # Ensures Machine Timer Interrupt Pending (MTIP) bit cannot be modified by write operations, maintaining read-only protection.
      '((mip & ${MIP_MEIP}) != 1)' : 0 # Ensures Machine External Interrupt Pending (MEIP) bit cannot be modified by write operations, maintaining read-only protection.

# This coverpoint validates memory-mapped Software Interrupt Pending (MSIP) functionality
# Checks MSIP register behavior during control register write operations
CHK_MSIP_FUNCTIONALITY:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrc: 0
      csrrs: 0  
      sw   : 0  
  val_comb: 
      # Verify MSIP set and clear mechanisms
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})' : 0 # Checks software interrupt pending mechanism when writing 1 to memory-mapped MSIP control register without immediate interrupt service.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MSIP}) == 0)' : 0 # Validates software interrupt clearing mechanism when writing 0 to memory-mapped MSIP control register.  

# This coverpoint validates software interrupt handling
# Ensures software interrupt is processed when global and local Machine Interrupt Enable (MIE) are active
CHK_M_SOFTWARE_INTR:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics:
      csrrc: 0
      csrrs: 0
      sw   : 0 
      mret : 0
  val_comb:
      # Validate various software interrupt scenarios
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == ${MSTATUS_MIE}) and ((mie & ${MIE_MSIE}) == 0) and ((mip & ${MIP_MSIP}) == 0)': 0 # Validates global interrupt enabled with local software interrupt disabled and encountrer no interrupt in pending.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == ${MSTATUS_MIE}) and ((mie & ${MIE_MSIE}) == ${MIE_MSIE}) and ((mip & ${MIP_MSIP}) == 0)': 0 # Validates global interrupt enabled with local software interrupt enabled and encountrer no interrupt.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == ${MSTATUS_MIE}) and ((mie & ${MIE_MSIE}) == 0) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})': 0 # Validates global interrupt enabled with local software interrupt disabled and interrupt became pending.
      # Validate interrupt context
      '(call_type == "interrupt") and ((mstatus & ${MSTATUS_MPP}) == ${MSTATUS_MPP_M}) and ((mstatus & ${MSTATUS_MPIE}) == ${MSTATUS_MPIE}) and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mcause & ${INTERRUPT_MASK}) == ${CAUSE_M_SOFT_INTR}) and ((mie & ${MIE_MSIE}) == ${MIE_MSIE}) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})': 0 Validates software interrupt handling, verifying machine status register configuration(MPP, MPIE, MIE), interrupt cause, and software interrupt enable/pending states.
      
# This coverpoint validates the handling of Most Significant Bit (MSB) in mtimecmp register
# Verifies signed/unsigned comparison behavior for timer registers
# Tests timer interrupt generation based on MSB comparison     
CHK_MTIMECMP_SIGN:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrc: 0
      csrrs: 0  
      sw   : 0  
  val_comb: 
      # Verify MTIP set and clear mechanisms
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MTIP}) == ${MIP_MTIP})' : 0 # Checks timer interrupt pending state when no interrupt is being serviced.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MTIP}) == 0)' : 0 # Confirms timer interrupt pending bit's behavior under non-interrupt execution.

# This coverpoint used to validate the 32-bit precision of machine timer (mtime) and timer compare (mtimecmp) register if MTIP hit for the 4 times
CHK_MTIME_LENGTH:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrc: 0
      csrrs: 0 
      sw   : 0   
  val_comb: 
      # Verify MTIP set and clear mechanisms
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MTIP}) == ${MIP_MTIP})' : 0 # Validates timer interrupt pending mechanism for 32-bit machine timer registers during non-interrupt execution.

# This coverpoint validates timer interrupt handling
# Ensures timer interrupt is processed when global and local Machine Interrupt Enable (MIE) are active
CHK_M_TIMER_INTR:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics:
      csrrc: 0
      csrrs: 0
      sw   : 0 
      mret : 0
  val_comb:
      # Validate various timer interrupt scenarios
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == ${MSTATUS_MIE}) and ((mie & ${MIE_MTIE}) == 0) and ((mip & ${MIP_MTIP}) == 0)': 0 # Validates global interrupt enabled with local timer interrupt disabled and encountrer no interrupt in pending.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == ${MSTATUS_MIE}) and ((mie & ${MIE_MTIE}) == ${MIE_MTIE}) and ((mip & ${MIP_MTIP}) == 0)': 0 # Validates global interrupt enabled with local timer interrupt enabled and encountrer no interrupt.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == ${MSTATUS_MIE}) and ((mie & ${MIE_MTIE}) == 0) and ((mip & ${MIP_MTIP}) == ${MIP_MTIP})': 0 # Validates global interrupt enabled with local timer interrupt disabled and interrupt became pending.
      # Validate interrupt context
      '(call_type == "interrupt") and ((mstatus & ${MSTATUS_MPP}) == ${MSTATUS_MPP_M}) and ((mstatus & ${MSTATUS_MPIE}) == ${MSTATUS_MPIE}) and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mcause & ${INTERRUPT_MASK}) == ${CAUSE_M_TIMER_INTR}) and ((mie & ${MIE_MTIE}) == ${MIE_MTIE}) and ((mip & ${MIP_MTIP}) == ${MIP_MTIP})': 0 # Validates timer interrupt processing by checking machine status, interrupt cause, and ensuring both local and global timer interrupt enables are active.

# This coverpoint validates Machine Timer Interrupt Pending (MTIP) functionality
# Checks MTIP register behavior during timer interrupt generation/clearing
CHK_MTIP_FUNCTIONALITY:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrc: 0
      csrrs: 0   
      sw   : 0 
  val_comb: 
      # Verify MTIP set and clear mechanisms
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MTIP}) == ${MIP_MTIP})' : 0 # Verifies Machine Timer Interrupt Pending (MTIP) bit setting mechanism during non-interrupt execution.
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mip & ${MIP_MTIP}) == 0)' : 0 # Checks MTIP bit clearing mechanism when no interrupt is being processed.

# This coverpoint validates global Machine Interrupt Enable (MIE) disable behavior
# Confirms no interrupts are taken when global interrupt is disabled
DIS_GLB_MIE:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrs: 0
      csrrc: 0
      sw   : 0 
  val_comb: 
      '(call_type != "interrupt") and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mie & ${MIE_MSIE}) == ${MIE_MSIE}) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})' : 0 # Confirms that no software interrupt is taken when global machine interrupt is disabled, despite local interrupt enable being active.

# This coverpoint validates global Machine Interrupt Enable (MIE) enable behavior
# Confirms interrupt processing when global interrupt is enabled
EN_GLB_MIE:
  config:
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics:
      csrrc: 0
      csrrs: 0
      sw   : 0 
      mret : 0
  val_comb:
      # Validate software interrupt handling
      '(call_type == "interrupt") and ((mstatus & ${MSTATUS_MPP}) == ${MSTATUS_MPP_M}) and ((mstatus & ${MSTATUS_MPIE}) == ${MSTATUS_MPIE}) and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mcause & ${INTERRUPT_MASK}) == ${CAUSE_M_SOFT_INTR}) and ((mie & ${MIE_MSIE}) == ${MIE_MSIE}) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})': 0 # Validates software interrupt processing when global machine interrupt is enabled, verifying all required interrupt conditions.

# This coverpoint validates M-mode interrupt delegation behavior
# Ensures M-mode interrupts are not delegated to S-mode when delegation is set
EN_M_INTR_DELEGATION:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); def rvtest_mtrap_routine=True;
  mnemonics: 
      csrrs: 0
      sw   : 0 
      mret : 0
  val_comb:
      # Validate software interrupt handling
      '(call_type == "interrupt") and ((mstatus & ${MSTATUS_MPP}) == ${MSTATUS_MPP_M}) and ((mstatus & ${MSTATUS_MPIE}) == ${MSTATUS_MPIE}) and ((mstatus & ${MSTATUS_MIE}) == 0) and ((mcause & ${INTERRUPT_MASK}) == ${CAUSE_M_SOFT_INTR}) and ((mie & ${MIE_MSIE}) == ${MIE_MSIE}) and ((mip & ${MIP_MSIP}) == ${MIP_MSIP})': 0 # Ensures M-mode software interrupts are processed within M-mode and not delegated to lower privilege levels.
